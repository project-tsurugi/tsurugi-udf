#include "rpc_client.h"
#include "{{ proto_base_name }}.grpc.pb.h"
#include "{{ proto_base_name }}.pb.h"

#include <iostream>
#include <stdexcept>

using grpc::ClientContext;
using grpc::Status;
using namespace plugin::udf;

// =======================
// Jinja2 filter for CamelCase
// =======================
{% macro camelcase(s) -%}
    {{- s.split('_') | map('capitalize') | join('') -}}
{%- endmacro %}

// =======================
// Macros (recursive code)
// =======================

{# 入力: request(generic_record)→req(Proto) に詰める #}
{% macro emit_setters(parent, record, cursor_prefix, is_pointer=False) -%}
    {% for col in record.columns %}
        {% if col.nested_record %}
            // Nested message: {{ col.column_name }}
            {
                auto* nested = {{ parent }}{% if is_pointer %}->mutable_{{ col.column_name }}(){% else %}.mutable_{{ col.column_name }}(){% endif %};
                {{ emit_setters("nested", col.nested_record, cursor_prefix ~ col.index ~ "_", True) }}
            }
        {% else %}
            auto arg{{ cursor_prefix }}{{ col.index }} = cursor->fetch_{{ fetch_add_name(col.type_kind) }}();
            {% if col.oneof_index is not none %}
                if (arg{{ cursor_prefix }}{{ col.index }}) {
                    {{ parent }}{% if is_pointer %}->set_{{ col.column_name }}(*arg{{ cursor_prefix }}{{ col.index }}){% else %}.set_{{ col.column_name }}(*arg{{ cursor_prefix }}{{ col.index }}){% endif %};
                }
                /* {{ col.oneof_index }} {{ col.oneof_name }} */
            {% else %}
                if (!arg{{ cursor_prefix }}{{ col.index }}) {
                    throw std::runtime_error("No input arg{{ cursor_prefix }}{{ col.index }}");
                }
                /* {{ col.oneof_index }} {{ col.oneof_name }} */
                {{ parent }}{% if is_pointer %}->set_{{ col.column_name }}(*arg{{ cursor_prefix }}{{ col.index }}){% else %}.set_{{ col.column_name }}(*arg{{ cursor_prefix }}{{ col.index }}){% endif %};
            {% endif %}
        {% endif %}
    {% endfor %}
{%- endmacro %}

{# 出力: rep(Proto)→response(generic_record) にフラットに積む #}
{% macro emit_response_add(parent, record, parent_type, is_pointer=False) -%}
    {% for col in record.columns %}
        {% if col.nested_record %}
            {
                // Flatten nested message: {{ col.column_name }}
                const auto& nested = {{ parent }}{% if is_pointer %}->{{ col.column_name }}(){% else %}.{{ col.column_name }}(){% endif %};
                {{ emit_response_add("nested", col.nested_record, parent_type, False) }}
            }
        {% else %}
            {% if col.oneof_index is not none %}
                // oneof field: add only if present
                if ({{ parent }}.{{ col.oneof_name }}_case() == {{ parent_type }}::k{{ col.column_name | camelcase }}) {
                    response.add_{{ fetch_add_name(col.type_kind) }}(
                        {{ parent }}.{{ col.column_name }}()
                    );
                }
            {% else %}
                response.add_{{ fetch_add_name(col.type_kind) }}(
                    {{ parent }}.{{ col.column_name }}()
                );
            {% endif %}
        {% endif %}
    {% endfor %}
{%- endmacro %}

// =======================
// Constructor: build stubs
// =======================

rpc_client::rpc_client(std::shared_ptr<grpc::Channel> channel)
{% set stubs = [] %}
{% for pkg in packages %}
    {% for svc in pkg.services %}
        {% set _ = stubs.append((pkg.package_name, svc.service_name)) %}
    {% endfor %}
{% endfor %}
    :
{% for pkg_name, svc_name in stubs %}
    {{ pkg_name }}_{{ svc_name }}_stub_(
        {{ pkg_name }}::{{ svc_name }}::NewStub(channel)
    ){% if not loop.last %},{% endif %}
{% endfor %}
{}

// =======================
// Call dispatcher
// =======================

void rpc_client::call(ClientContext& context,
                      function_index_type function_index,
                      generic_record& request,
                      generic_record& response) const {
    auto cursor = request.cursor();
    if (!cursor) { throw std::runtime_error("request cursor is null"); }

    response.reset();
    auto fail = [&response]() { response.add_string("RPC failed"); };

    switch (function_index.second) {
{% for pkg in packages %}
  {% for svc in pkg.services %}
    {% for fn in svc.functions %}
        case {{ fn.function_index }}: {
            {{ fn.input_record.record_name  | replace('.', '::') }}  req;
            {% set parent_type = fn.output_record.record_name | replace('.', '::') %}
            {{ fn.output_record.record_name | replace('.', '::') }}  rep;

            // Build request from generic_record (flatten -> nested)
            {{ emit_setters("req", fn.input_record, "", False) }}

            // Call
            Status status = {{ pkg.package_name }}_{{ svc.service_name }}_stub_->{{ fn.function_name }}(&context, req, &rep);

            if (status.ok()) {
                // Write response into generic_record (nested -> flatten)
                {{ emit_response_add("rep", fn.output_record, parent_type, False) }}
            } else {
                response.set_error(error_info(
                    static_cast<error_info::error_code_type>(status.error_code()),
                    std::string(status.error_message())
                ));
            }
            break;
        }
    {% endfor %}
  {% endfor %}
{% endfor %}
        default:
            throw std::runtime_error("Unsupported function_index");
    }
}
