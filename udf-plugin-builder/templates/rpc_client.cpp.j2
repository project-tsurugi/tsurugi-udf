#include "rpc_client.h"
#include "sample.grpc.pb.h"
#include "sample.pb.h"

#include <iostream>
#include <stdexcept>

using grpc::ClientContext;
using grpc::Status;
using namespace plugin::udf;
rpc_client::rpc_client(std::shared_ptr<grpc::Channel> channel)
{% set stubs = [] %}
{% for pkg in packages %}
    {% for svc in pkg.services %}
        {% set _ = stubs.append((pkg.package_name, svc.service_name)) %}
    {% endfor %}
{% endfor %}
    :
{% for pkg_name, svc_name in stubs %}
    {{ pkg_name }}_{{ svc_name }}_stub_(
        {{ pkg_name }}::{{ svc_name }}::NewStub(channel)
    ){% if not loop.last %},{% endif %}
{% endfor %}
    {}
void rpc_client::call(ClientContext& context, function_index_type function_index,
    generic_record& request, generic_record& response) const {
    auto cursor = request.cursor();
    if (!cursor) { throw std::runtime_error("request cursor is null"); }

    response.reset();
    auto fail = [&response]() { response.add_string("RPC failed"); };
    switch (function_index.second) {
{% for pkg in packages %}
  {% for svc in pkg.services %}
    {% for fn in svc.functions %}
        case {{ fn.function_index }}: {
            {{ fn.input_record.record_name | replace('.', '::') }} req;
            {{ fn.output_record.record_name | replace('.', '::') }} rep;
            {% for col in fn.input_record.columns %}
              auto arg{{ col.index }} = cursor->fetch_{{ fetch_add_name(col.type_kind) }}();
              if (!arg{{ col.index }}) { throw std::runtime_error("No input arg{{ col.index }}"); }
              req.set_{{ col.column_name }}(*arg{{ col.index }});
            {% endfor %}
              Status status = {{ pkg.package_name }}_{{ svc.service_name }}_stub_->{{ fn.function_name }}(&context, req, &rep);
              if (status.ok()) {
            {% for col in fn.output_record.columns %}
                  response.add_{{ fetch_add_name(col.type_kind) }}(rep.{{ col.column_name }}());
            {% endfor %}
              } else {
                  fail();
              }
              break;
        }
    {% endfor %}
  {% endfor %}
{% endfor %}
        default: throw std::runtime_error("Unsupported function_index (only 1 or 2 allowed)");
    }
}
